%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PIESIM_DDE_DEMO.m     PIETOOLS 2021d
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PIESIM Version: 2021d
% date: 9/28/2021
% NOTE:
% For support, contact Y. Peet, Arizona State University at ypeet@asu.edu
% S. Shivakumar, Arizona State University at sshivak8@asu.edu


% This is a demo file for simulation of DDEs using PIESIM code.
% It perfoms the following functions:
% 1) Sets up the DDE problem (either by calling an example from the library
% or setting it up manually)
% 2) Finds a PIE (constructs closed-loop observer or controller if
% specified)
% 2) Call the executive solver for PIESIM (exectuive_PIESIM.m)

% The executive rotuine performs the following functions:
% 1) Checks if all inputs are defined and (if not) setting up default
% options
% 1) Converts the DDE to PIE problem
% 2) Discretizes the PIE operators with Chebyshev polynomials
% 3) Temporally integrates the corresponding spatially-discretized
% equations (3 temporal schemes are possible: BDF, Gauss integration, and
% analytical integraiton - see options in solver_PIESIM.m)
% 4) Outputs and plots the PDE and ODE solutions at a final time and
% (if opts.intScheme=1) - plots the ODE solutions versus time
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% If you modify this code, document all changes carefully and include date,
% authorship, and a brief description of modifications
%
% Initial coding SS  - 9_28_2021, this code is a modified version of
% solver_PIESIM.m file written by Yulia Peet
%
clear;
clc;
close all;
format long;
pvar s theta;
stability=0; stability_dual=0; Hinf_gain=0; Hinf_gain_dual=0; Hinf_control=0; Hinf_estimator=0;
sosineq_on=1; DDE_minimal_rep=1;


%--------------------------------------------------------------
% SETUP OF THE SIMULATIONS
% USER INPUT BEGINS
%--------------------------------------------------------------



% Two options to do initialization of the PDE/PDE+ODE/DDE problem.

% OPTION 1 (set "init_option=1"): choose one of the examples from the library (examples_dde_library_PIESIM)


% OPTION 2 (set "init_option=2"): Define your own input structure below

init_option=1;
%------------------------------------------------------------------------------

% OPTION 1: choose one of the cexamples from the library (examples_dde_library_PIESIM)
%  open the examples_dde_library_PIESIM, uncomment the DDE to be simulated
%  and comment out the remaining examples

if (init_option==1)
    examples_DDE_library_PIETOOLS;
    
    if ~exist('DDE','var')
        error('No DDE selected in the examples library');
    end
    
    
elseif (init_option==2)
    %------------------------------------------------------------------------------
    % OPTION 2: Place your own input structure below
    %------------------------------------------------------------------------------
    %
    % A required input: DDE structure (consult PIETOOLS manual)
    %
    % Optional inputs: initial conditions, inhomogeneous inputs uinput, winput
    % NOTE: if initial conditions are not specified, they will be defaulted to
    % zero.
    %------------------------------------------------------------------------------
    %   PUT YOUR INPUT BELOW
    %------------------------------------------------------------------------------
    %   USER INPUT BEGINS
    %------------------------------------------------------------------------------
    
    DDE.A0=[0];
    DDE.Ai{1}=[-1];
    DDE.B1=[1];
    DDE.C1=[1];
    DDE.D11=[1];
    DDE.tau(1)=1.5;
    
end % User-defined initialization option


% If exact solution is known and is desired to be provided for testing,
% select ifexact=true and provide an exact solution as a function in
% symolic form using symbolic variables sx (for space), st (for time)
% NOTE: only choose ifexact=true if exact solution for all the states is
% available. Otherwise, choose ifexact=false.

%exact(1) = sin(pi*sx)*exp(-nu*pi^2*st);

%  uinput.ifexact=true;

uinput.ifexact=false;


%------------------------------------------------------------------------------
%   USER INPUT ENDS
%------------------------------------------------------------------------------
%------------------------------------------------------------

% Input N - the Chebyshev polynomial discretization order of the primary
% state

%-------------------------------------------------------------

opts.N=8;

%-----------------------------------------------------------

% Input the desired final time of the solution

opts.tf=30;

%  Choose temporal integration scheme
%  opts.intScheme = 1 - Backward Differentiation Formula (BDF)
%  opts.intScheme = 2 - Gauss evaluation of the analytical solution
%  opts.intScheme = 3 - Analytical integration in symbolic form
%  Note: opts.intScheme=3 will only work if the boundary and forcing inputs are simple integrable
%  functions of time, and the matrix Atotal=inv(M)*A is diagonalizable.
%  An error will be issued if matrix is not diagonalizable, and a default
%  integration scheme given by  opts.intScheme = 1
%  (BDF) of order 2 (opts.Norder=2) will be executed.
%  Note: symbolic integration is also the slowest (however, the most accurate when it works).
%  BDF is the fastest, but less accurate
%  Choose opts.intScheme=1 if a temporal history of solution is required
%  (this is the only scheme that provides it)

%------------------------------------------------
opts.intScheme=1;
%------------------------------------------------


% if opts.intScheme = 1
% Choose the order of numerical time integration scheme (Norder).
% A time integration scheme available is Backward Differentiation Formula (BDF).
% Norder = 1, 2, 3 or 4 can be chosen. Lower order yield more robust schemes, and higher
% order more accurate schemes
% Also input the desired time step (dt)

if (opts.intScheme==1)
    Norder = 2;
    dt=0.01;
    
    % NOTE: if tf is not divisible by dt, dt will be adjusted to a closest dt
    % value to yield an integer number of time steps
    
    Nsteps=floor(opts.tf/dt);
    dt=opts.tf/Nsteps;
    
    opts.Norder=Norder;
    opts.dt=dt;
    opts.Nsteps=Nsteps;
end

% if opts.intScheme = 2
% Choose the number of untervals for Gauss evaluation of the integral (Nint)
% Choose the number of Gauss integration points per interval (Npgauss)

if (opts.intScheme==2)
    opts.Nint=1;
    opts.Npgauss=100;
end


% Check if PDE, opts and input structures are defined
%if ~exist('PDE','var')
%error('PDE structure is undefined. It is necessary for executing the code');
%end
if ~exist('uinput','var')
    disp('Warning: user input structure ``uinput'' is not defined. Defaulting to zero');
    uinput=struct;
end

plot_no_control = 1; % this setting first runs simulation without controller for same IC

if (~Hinf_control && ~Hinf_estimator)|| plot_no_control
    solution=executive_PIESIM(DDE,opts,uinput);
end
%%% Construct and solve the LPI corresponding to the problem you specified earlier
if Hinf_control
    syms sx st;
    DDE=initialize_PIETOOLS_DDE(DDE); % error checking and preprocessing
    DDF=minimize_PIETOOLS_DDE2DDF(DDE);
    PIE=convert_PIETOOLS_DDF2PIE(DDF);
    
    sosineq_on=0; % binary variable indicating whether to use ineqaulity or equality constraint
    
    % settings_PIETOOLS_veryheavy
    % settings_PIETOOLS_heavy
    %      settings_PIETOOLS_light;
    % settings_PIETOOLS_stripped
    % settings_PIETOOLS_extreme
    settings_PIETOOLS_custom
    
    settings.sos_opts.solver = 'sedumi';
    %     settings.sos_opts.solver ='mosek';
    % settings.sos_opts.solver='sdpnalplus';
    % settings.sos_opts.solver='sdpt3';
    settings.eppos = 1e-4;      % Positivity of Lyapunov Function with respect to real-valued states
    settings.eppos2 = 0*1e-4;   % Positivity of Lyapunov Function with respect to spatially distributed states
    settings.epneg = 0*1e-5;    % Negativity of Derivative of Lyapunov Function
    [prog, K, gamma, P, Z] = executive_PIETOOLS_Hinf_control(PIE,settings);
    PIE = closedLoopPIE(PIE,K);
    
    psize.nu=PIE.Tu.dim(1,2);
    psize.nw=PIE.Tw.dim(1,2);
    psize.nx=PIE.T.dim(1,1);
    psize.nf=0;
    ns=PIE.T.dim(2,1);
    psize.N=opts.N;
    psize.n=ns;
    uinput.a=-1;
    uinput.b=0;
    uinput.ifexact=false;
    % All this should go into subroutine
    
    if (psize.nw>0)
        if ~isfield(uinput,'w')
            disp('Disturbances are not defined. Defaulting to a user-specified signal type');
            if ~isfield(opts,'dist')
                disp('Signal type for disturbances is not defined. Defaulting to a sinusoidal type');
                uinput.w(1:psize.nw)=sin(st);
            else
                switch opts.dist
                    case 'constant'
                        uinput.w(1:psize.nw)=1+0*st;
                    case 'sin'
                        uinput.w(1:psize.nw)=sin(st);
                    case 'sinc'
                        uinput.w(1:psize.nw)=sinc(st);
                    otherwise
                        disp('Signal type for disturbances is not defined. Defaulting to a sinusoidal type');
                        uinput.w(1:psize.nw)=sin(st);
                end
            end
        end
    end
    n_diff = PIE.T.dim(2,1);
    uinput.a=-1;
    uinput.b=0;
    uinput.ifexact=false;
    if ~isfield(uinput,'ic')
        disp('Initial conditions on ODE states are not defined. Defaulting to 1');
        uinput.ic.ODE(1:psize.nx)=1;
        disp('Initial conditions on history are not defined. Defaulting to 1');
        uinput.ic.PDE(1:ns)=1;
    else
        if ~isfield(uinput.ic,'ODE')
            disp('Initial conditions on ODE states are not defined. Defaulting to 1');
            uinput.ic.ODE(1:psize.nx)=1;
        end
        if ~isfield(uinput.ic,'PDE')
            disp('Initial conditions on history are not defined. Defaulting to 1');
            uinput.ic.PDE(1:ns)=1;
        end
    end
    
    solution=executive_PIESIM(PIE,opts,uinput,n_diff);
end





