function out = subsref(obj,s)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% out=subsref(Pbop,s) used for subscripted indexing of the operator 
% P: R^p x L2^q to R^m x L2^n
% 
% INPUT
% obj: nopvar class object to slice
% s: structure of indices used for reference (auto generated by matlab
% based on subscript expression
% 
% OUTPUT
% out: nopvar object (if slicing the operator), otherwise depends on the
% subscript expression
%
% NOTES:
% For support, contact M. Peet, Arizona State University at mpeet@asu.edu
% or S. Shivakumar at sshivak8@asu.edu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PIETools - subsref
%
% Copyright (C)2025  PIETOOLS Team
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% If you modify this code, document all changes carefully and include date
% authorship, and a brief description of modifications
%
% Initial coding AT 01/26/2026

switch s(1).type
    case '.'
        out = builtin('subsref',obj,s);
    case '()'
        indr = s(1).subs{1}; %output
        indc = s(1).subs{2}; %input
        dim_old=obj.dim;

        nr1_old=dim_old(1); % output dimension
        nr2_old=dim_old(2); % input dimension

        % Allow indices to be specified as e.g. (i,:);
        if strcmp(indr,':') && strcmp(indc,':')
            out = obj;
            return
        end
        if strcmp(indr,':')
            indr = (1:nr1_old);
        end
        if strcmp(indc,':')
            indc = (1:nr2_old);
        end


        if size(indr, 1) == 1
            indr = indr';
        end
        if size(indc, 1) == 1
            indc = indc';
        end


        % Construct the sliced opvar
        Psop = nopvar();
        Psop.dom = obj.dom;
        Psop.deg = obj.deg;
        Psop.vars = obj.vars; 
        N = size(obj.dom,1);
        Psop.C = cell([3*ones(1,N),1]);

        dec_var_NEW = []; % nopvar no dec var
        binStr = dec2base(0:(3^N-1), 3);% create indexing for C{i}
        
        size_of_monom = prod(obj.deg+1); % size of monomimials 
        
        Loc_L_R = size_of_monom*(indr - 1) + 1; % starting location of C rows
        Loc_L_R= [kron(Loc_L_R, ones(size_of_monom, 1)), kron( ones(length(Loc_L_R), 1), (0:(size_of_monom-1))' )];
        Loc_L_R = sum(Loc_L_R, 2);
        for iter_idx = 1:size(binStr, 1)
        
            substr = binStr(iter_idx, :);
            Qindx = str2num(substr')'+1; % array of .C indeces
            Qindx_cell = num2cell(Qindx); % cell array of .C indeces
        
            index_for_monom_in_theta = Qindx == 1; % include monomials for theta
        
            subdegree1 = obj.deg;
            subdegree1(index_for_monom_in_theta) = 0;
        
            size_of_monom_c = prod(subdegree1 + 1);
            Loc_L_C = size_of_monom_c*(indc - 1) + 1; % starting location of C columns
            Loc_L_C= [kron(Loc_L_C, ones(size_of_monom_c, 1)), kron( ones(length(Loc_L_C), 1), (0:(size_of_monom_c-1))' )];
            Loc_L_C = sum(Loc_L_C, 2);
        
            % change Cop values
            % full_matrix = sparse(len(indr)*size_of_monom*(length(dec_var_NEW) + 1), size_of_monom_c*len(indc) );
            full_matrix = obj.C{Qindx_cell{:}};
            Psop.C{Qindx_cell{:}} = full_matrix(Loc_L_R, Loc_L_C);
        end

        if length(s)>=2
            out = builtin('subsref',Psop,s(2:end));
        else
            out = Psop;
        end
    case '{}'
        error('Not a valid indexing expression')
end
end
